<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>transH</title>
      <link href="/2020/01/28/transh/"/>
      <url>/2020/01/28/transh/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们处理将由实体和关系组成的大规模知识图谱嵌入到连续向量空间中的问题。TransE是一种有效的嵌入方法。但是 ，TranE方法适用于一对一关系，在处理自反，一对多，多对一和多对多的关系上做的并不好；同时，一些复杂的模型能够很好的处理这些复杂关系，但是效率低下，为了平衡模型容量和效率，提出了TransH。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li>分析TransE在自反/一对多/多对一/多对多关系上的问题</li><li>提出TransH解决方法</li><li>如何构建负例以减少训练中的虚假负例</li></ul><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>$h$：head entity</p><p>$r$ ：relation</p><p>$t$ ：tail entity</p><p>$\textbf{h},\textbf{r},\textbf{t}$ ：连续空间内的向量</p><p>$\Delta$ :：组集合</p><p>$\Delta^{’}$ ：错误三元组集合</p><p>$E$ ：实体集合</p><p>$R$ ：关系集合</p><h2 id="transE算法存在的问题"><a href="#transE算法存在的问题" class="headerlink" title="transE算法存在的问题"></a>transE算法存在的问题</h2><ul><li>transE模型的两个结论<ul><li>如果$(h,r,t)∈Δ$ and​ $(t,r,h)\in\Delta$ ,即 关系$r$ 是一个自反的映射，那么可以知道$r=0$ 并且$h=t$ </li><li>如果$\forall_i\in\{0,1,2,\cdots,m\},(h_i,r,t)\in\Delta$ ,也就是说r是一个多对一的映射，那么$h_0=h_1=h_2=\cdots=h_m$ .同理，对于$\forall_i,(h,r,t_i)\in\Delta$是一个多对一的映射，那么可以知道$t_0=t_1=t_2=\cdots=t_n$ </li></ul></li><li>从上述结果可以发现，transE算法在处理自反关系，以及多对一、一对多、多对多关系中，会使得一些不同的实体具有相同或者相似的向量。其根本原因在于，<strong>出现在多个关系中的同一个实体的表示是相同的</strong>。</li></ul><h2 id="tranH"><a href="#tranH" class="headerlink" title="tranH"></a>tranH</h2><ul><li><p>核心思想</p><p>每一个关系定义一个超平面$W_r$ ,和一个关系向量$d_r$ 。$h_{\bot},t_{\bot}$是h，t在$W_r$ 上的投影，我们希望正确的三元组满足$h_{\bot}+d_r=t_{\bot}$ 。这样能够使得同意实体在不同关系中的意义不同，同时不同实体，在同一关系中的意义，也可以相同。<br><img src="/images/transH/1.png" alt="1"></p></li><li><p>得分函数</p><script type="math/tex; mode=display">d(h+r,t)=f_r(h,t)=\lVert h_{\bot}+d_r-t_{\bot}\rVert_2^2</script></li></ul><p>  对于平面$W_r$ 我们可以使用法向量来表示，我们不妨假设$w_r$ 为平面$W_r$ 的法向量，并加约束条件$\lVert w_r\rVert_2^2=1$,所以我们知道h在$w_r$ 上的投影为</p><script type="math/tex; mode=display">  h_{w_r}=w^Thw</script><p>  这是因为$w^T=|w||h|cos\theta$ 表示h在w方向上投影的长度，再乘以w即为h在w上的投影，所以得出</p><script type="math/tex; mode=display">  f_r(h,t)=\lVert h_{\bot}+d_r-t_{\bot}\rVert_2^2=\lVert h-h_{w_r}+d_r-(t-t_{w_r})\rVert_2^2=\lVert h-w^Thw+d_r-(t-w^Ttw)\rVert_2^2</script><p><img src="/images/transH/2.png" alt="2"></p><ul><li>代价函数</li></ul><script type="math/tex; mode=display">L=\sum_{(h,r,t)\in\Delta}\sum_{(h^{'},r^{'},t^{'})\in \Delta}[f_r(h,t)+\gamma+f_{r^{'}(h^{'},t^{'})}]_+</script><p>在公式中，$[x]_+\triangleq max(x,0)$ </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 知识图谱嵌入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TranH论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cuda_knowledge</title>
      <link href="/2020/01/20/cuda-knowledge/"/>
      <url>/2020/01/20/cuda-knowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="cuda的相关操作"><a href="#cuda的相关操作" class="headerlink" title="cuda的相关操作"></a>cuda的相关操作</h2><ol><li><p>查看驱动版本</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">nvidia-smi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令还可以实时显示GPU的使用情况</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">watch -n 1 nvidia-smi  #一秒刷新一次<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="不错的参考资料"><a href="#不错的参考资料" class="headerlink" title="不错的参考资料"></a>不错的参考资料</h2><p><a href="https://www.cnblogs.com/yhjoker/p/10972795.html" target="_blank" rel="noopener">Pytorcha 使用不同版本的cuda</a></p><p><a href="https://www.cnblogs.com/marsggbo/p/11838823.html" target="_blank" rel="noopener">显卡，显卡驱动，nvcc,cuda概念的介绍</a></p><p><a href="https://www.jianshu.com/p/9f89633bad57" target="_blank" rel="noopener">安装详解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>link prediction</title>
      <link href="/2020/01/15/link-prediction/"/>
      <url>/2020/01/15/link-prediction/</url>
      
        <content type="html"><![CDATA[<h2 id="链路预测的背景"><a href="#链路预测的背景" class="headerlink" title="链路预测的背景"></a>链路预测的背景</h2><p>通常来说，KB以三元组 (h, r, t) 的集合的形式呈现，其中 h是头实体，t是尾实体，而r是关系。例如，（巴黎，是首都，法国）就是一个知识三元组。尽管现存的KB包含了很多这样的信息，但众所周知，KB中仍有大量的知识缺失。这催生了大量关于“知识图谱补全（Knowledge Base Completion）”任务的研究，该任务旨在基于现有的KB的内容来填充缺失的知识，而最常见的情况是，知识图谱补全以链接预测的形式来实现。</p><h2 id="链路预测的任务"><a href="#链路预测的任务" class="headerlink" title="链路预测的任务"></a>链路预测的任务</h2><p>链接预测任务预测<font color="red">未在</font>知识图谱中出现的三元组成立的可能性，是对知识图谱进行补全的有效方式，其==核心思想是基于知识图谱中的已知事实对未在知识图谱中出现的三元组的合理性进行评估，选取合理性较高的事实加入知识图谱对原有知识进行补全从而提高知识图谱的质量==。</p><p>知识图谱上的链接预测目的是为了能够预测出一个三元组（h，r，t）缺失的头实体h，尾实体t或者关系r</p><h2 id="链路预测方法"><a href="#链路预测方法" class="headerlink" title="链路预测方法"></a>链路预测方法</h2><ul><li><p><strong><em>基于表示的链接预测方法</em></strong>：对知识图谱中的实体和关系进行合适的表示，拟合一个函数f，函数的输入为三元组中两个实体和其关系的表示（也有部分模型的输入还包含在知识图谱中将两个实体关联起来的路径），输出为该三元组(s, r, o)的评分，将评分视为该三元组成立的置信度，从而完成链接预测。基于表示的链接预测方法大部分依赖知识图谱嵌入(Knowledge Graph Embedding, KGE)的技术，KGE将知识图谱中的实体和关系表示为低维的连续向量，在保留知识图谱结构信息的同时简化知识图谱上的操作。</p><p>基于表示的链接预测方法大部分依赖知识图谱嵌入(Knowledge Graph Embedding, KGE)[3]的技术，KGE将知识图谱中的实体和关系表示为低维的连续向量，在保留知识图谱结构信息的同时简化知识图谱上的操作。</p><p>KGE一般包含三步：1.确定实体和关系的表示方法；2.定义评分函数衡量三元组(s, r, o)的合理性；3.训练模型，最大化知识图谱中正例的评分函数，学习实体和关系的表示。使用KGE模型进行链接预测时选择合理性较高的三元组作为预测得到的事实。</p><ul><li><p><strong>翻译距离模型</strong>(Translational Distance Models)</p><p>此类模型基于距离的评分函数构建。对于三元组(s, r, o)，测量经过关系r进行转换后两个实体s和o之间的距离，距离越小该三元组成立的可能性越高。在训练过程中应使训练数据中正例实体间距离较小，负例实体间的距离较大。此类方法研究很多，以TransE 为代表，改变关系转换方式、距离测量方式和实体表示方式可以衍生出多种不同的具体算法，例如TransH，TransR等。-</p></li><li><p><strong>语义匹配模型(Semantic Matching Models)</strong></p><p>语义匹配模型基于相似性评分函数，通过匹配实体和关系的潜在语义衡量事实的合理性，常见的方法有两大类：</p><ul><li>基于张量分解的方法</li><li>基于深度神经网络的方法</li></ul></li></ul></li><li><p>基于规则的链接预测方法：在知识图谱中的已知事实中挖掘通用的规则，得到一组规则以及每条规则相对应的置信度，对于每个查询的三元组(s, r, o)，将其与规则集合中的规则进行匹配，集成匹配结果得到三元组的置信度，从而完成链接预测。</p><p>基于规则的链接预测的研究主要关注如何评估规则的置信度，如何设置合理的假设空间，如何构建有效的在启发式策略在庞大的假设空间中高效搜索，如何设置合适的筛选条件进行剪枝操作。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>微信公众号openKE：浅谈知识图谱中的链接预测</p></li><li><p><a href="http://www.doc88.com/p-3804861825877.html" target="_blank" rel="noopener">基于位置的知识图谱连接预测</a></p></li><li><p><a href="https://blog.csdn.net/tgqdt3ggamdkhaslzv/article/details/97196258" target="_blank" rel="noopener">基于层次约束的链接预测</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> KG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KRL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基础一</title>
      <link href="/2020/01/12/xian-xing-dai-shu-ji-chu-yi/"/>
      <url>/2020/01/12/xian-xing-dai-shu-ji-chu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="basic-conception"><a href="#basic-conception" class="headerlink" title="basic conception"></a>basic conception</h1><h2 id="Zero-Matrix"><a href="#Zero-Matrix" class="headerlink" title="Zero Matrix"></a>Zero Matrix</h2><p>matrix with all zero entries, denoted by $O$ (any size) or $O_{m \times n}$</p><p>For example, a 2-by-3 zero matrix can be denoted</p><script type="math/tex; mode=display">O_{2 \times 3} = \left[\begin{matrix}  0 & 0 & 0\\  0 & 0 & 0 \\\end{matrix}\right]</script><h2 id="Identity-Matrix"><a href="#Identity-Matrix" class="headerlink" title="Identity Matrix"></a>Identity Matrix</h2><p> must be square,Sometimes $ I_n $  is simply written as $I$ (any size). </p><script type="math/tex; mode=display">I_3 = \left[\begin{matrix}  1 & 0 & 0\\  0 & 1 & 0 \\  0 & 0 & 1\end{matrix}\right]</script><h2 id="0-1-matrices"><a href="#0-1-matrices" class="headerlink" title="$(0,1)$ matrices"></a>$(0,1)$ matrices</h2><p>all the entities of A are zeros and ones called (0,1)matrices.</p><script type="math/tex; mode=display">I_3 = \left[\begin{matrix}  0&1 & 1 & 0\\  1 & 0 & 0&1 \\  1&0&0&0\\  0 & 1 & 0&0\end{matrix}\right]</script> <font color="red">get symmetirc matrix:$A^TA$</font>   <p>在生活中，我们会经常用到(0,1)矩阵(涉及图)</p><h2 id="Standard-Vectors"><a href="#Standard-Vectors" class="headerlink" title="Standard Vectors"></a>Standard Vectors</h2><p>we can write any vector $\left[<br>\begin{matrix}<br>  {a}\\<br>  {b}\\<br>\end{matrix}<br>\right]$in $R^2$ as a linear combination of the two vectors $\left[<br>\begin{matrix}<br>  {1}\\<br>  {0}\\<br>\end{matrix}<br>\right]$and$\left[<br>\begin{matrix}<br>  {0}\\<br>  {1}\\<br>\end{matrix}<br>\right]$</p><p>as follows:</p><script type="math/tex; mode=display">\left[\begin{matrix}  {a}\\  {b}\\\end{matrix}\right]=a\left[\begin{matrix}  {1}\\  {0}\\\end{matrix}\right]+b\left[\begin{matrix}  {0}\\  {1}\\\end{matrix}\right]</script><p>the vectors $\left[<br>\begin{matrix}<br>  {1}\\<br>  {0}\\<br>\end{matrix}<br>\right]$ and$\left[<br>\begin{matrix}<br>  {0}\\<br>  {1}\\<br>\end{matrix}<br>\right]$ are called the standard vectors of $R^2$ .</p><p>In general, we define the standard vectors of $R^n$ by</p><script type="math/tex; mode=display">e_1 =\left[\begin{matrix}  {1}\\  {0}\\  {\vdots}\\  {0}\end{matrix}\right]\qquad e_2 =\left[\begin{matrix}  {0}\\  {1}\\  {\vdots}\\  {0}\end{matrix}\right]\qquad \cdots \qquad e_n =\left[\begin{matrix}  {0}\\  {0}\\  {\vdots}\\  {1}\end{matrix}\right]</script><h2 id="Linear-Combination"><a href="#Linear-Combination" class="headerlink" title="Linear Combination"></a>Linear Combination</h2><ul><li>Given a vector set $\{u_1,u_2,\cdots,u_k\}$</li><li>The linear combination of the vectors in the set: <ul><li>$𝑣 = 𝑐1𝑢1 + 𝑐2𝑢2 + ⋯ + 𝑐𝑘𝑢𝑘$</li><li>$ 𝑐1, 𝑐2, ⋯ , 𝑐𝑘 $ are scalars (Coefficients of linear combination)</li></ul></li><li>the set of coefficients that express one vector as a linear combination of the others need not be unique</li><li>以线性方程组的思想理解线性组合</li></ul><script type="math/tex; mode=display">\begin{equation}  \left\{  \begin{array}{c}  a_{11}x_1+a_{12}x_{2}+...+a_{1n}x_{n} = b_{1} \\  a_{21}x_1+a_{22}x_{2}+...+a_{2n}x_{n} = b_{2} \\          \vdots\\  a_{m1}x_1+a_{m2}x_{n}+...+a_{mn}x_{n} = b_{n}  \end{array}\right.\end{equation}</script><script type="math/tex; mode=display">A =\left[\begin{matrix}  \mathbf{a_1}&\mathbf{a_2}&\mathbf{\cdots},\mathbf{a_n}\end{matrix}\right]</script><script type="math/tex; mode=display">x =\left[\begin{matrix}  {a_1}\\  {a_2}\\  {\vdots}\\  {a_n}\end{matrix}\right]\qquad coeffients</script><script type="math/tex; mode=display">\color{blue}{A}\color{red}{x} \color{black}=\color{red}{x_1}\color{blue}{a_1}\color{black}+\color{red}{x_2}\color{blue}{a_2}\color{black}+\color{red}{x_3}\color{blue}{a_3}\color{black}+\cdots\color{black}+\color{red}{x_n}\color{blue}{a_n}</script><p>$A{\color{red}{x}}=b$：b是向量集A的线性组合，x是系数集，若方程组有无数解，则x不唯一。</p><h2 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h2><ul><li>A vector set $S=\{u_1,u_2,{\cdots},u_k\}$ </li><li><p>Span of 𝑆 is the vector set of all linear combinations of $𝑢_1$, $𝑢_2$, ⋯ , $𝑢_k$ </p><ul><li><p>Denoted by 𝑆𝑝𝑎𝑛 $\{𝑢_1,𝑢_2, ⋯ ,𝑢_𝑘 \}$ or S𝑝𝑎𝑛  S</p></li><li><p>𝑆𝑝𝑎𝑛 𝑆 = $\{c_1u_1+c_2u_2+\cdots+c_ku_kfor\quad all |c_1,c_2,\cdots,c_k\}$ </p></li><li><p>Vector set $𝑉$ = 𝑆𝑝𝑎𝑛 $S$</p><ul><li>𝑆 is a generating set for 𝑉” or “𝑆 generates V” </li></ul></li></ul><ul><li>A vector set generated by another vector set is called <font color="red">Space </font></li></ul></li></ul><p><img src="/images/linear_algebra/span.png" alt="span"></p><ul><li>m independent vectors can span $R^m$ —-&gt;More than m vectors in $R^m $ must be dependent</li><li>m independent vectors can span $R^m$ —-&gt;More than m vectors in $R^m$  must be dependent</li></ul><h2 id="Dependent-and-Independent"><a href="#Dependent-and-Independent" class="headerlink" title="Dependent and Independent"></a>Dependent and Independent</h2><p>A set of n vectors $\{𝒂_1,𝒂_2,\cdots,𝒂_𝑛\}$ is linear dependent </p><ul><li><p>If there exist scalars 𝑥1, 𝑥2, ⋯ , 𝑥𝑛, <font color="red">not all zero</font>,</p></li><li><p>such that </p><script type="math/tex; mode=display">𝑥_1𝒂_1 + 𝑥_2𝒂_2 +\cdots+ 𝑥_𝑛𝒂_𝑛=0</script></li><li><p>A set of n vectors $\{𝒂_1, 𝒂_2,\cdots, 𝒂_𝑛\}$ is linear independent </p><script type="math/tex; mode=display">𝑥_1𝒂_1 + 𝑥_2𝒂_2 +\cdots+ 𝑥_𝑛𝒂_𝑛=0</script><p>Only if $𝑥1 = 𝑥2 = ⋯ = 𝑥𝑛 = 0$ </p></li></ul><font color="blue">Any set contains zero vector would be linear dependent</font> <h2 id="reduced-row-echelon-form-简化行阶梯形矩阵"><a href="#reduced-row-echelon-form-简化行阶梯形矩阵" class="headerlink" title="reduced row echelon form(简化行阶梯形矩阵)"></a>reduced row echelon form(简化行阶梯形矩阵)</h2><ul><li><p>Row Echelon Form</p><ul><li>Each nonzero row lies above every zero row（all its entries are 0）</li><li>The leading entries are in echelon form(阶梯型)</li></ul></li><li><p>reduced row echelon form</p><ul><li><p>The matrix is in row echelon form</p></li><li><p>The columns containing the leading entries are standard vectors</p><p><img src="/images/linear_algebra/ref.png" alt="ref"></p></li></ul></li><li><p>RREF在求解线性方程组中的应用</p><ul><li>一个线性方程组可以用增广矩阵来表示，对增广矩阵进行任何的基本行操作，解集不变</li><li>形如简化阶梯形矩阵可以很容器求出解集。<ul><li>当rref矩阵包含除最后一个元素非零的一行：无解</li><li>当rref矩阵的系数矩阵为单位矩阵：唯一解</li><li>其他情况：无穷解<ul><li>basic variables</li><li>free variables</li></ul></li></ul></li></ul></li><li><p>RREF的性质</p><ul><li>COLIMNS:If 𝒂𝒋 is a linear combination of other columns of A( with the same coefficients)&lt;—-&gt; 𝒓𝒋 is a linear combination of the corresponding columns of R with the same coefficients</li><li>ROWS:span$\{row_1,row_2,\cdots,row_n\}$ &lt;—-&gt;span$\{row^1,row^2,\cdots,row^n\}$ </li><li>The pivot columns are linear independent</li><li>The non-pivot columns are the linear combination of the previous pivot columns.</li></ul></li></ul><h2 id="Having-Solution-or-Not-of-system-of-linear-equations"><a href="#Having-Solution-or-Not-of-system-of-linear-equations" class="headerlink" title="Having Solution or Not of system of linear equations"></a>Having Solution or Not of system of linear equations</h2><ul><li>Is 𝑏 a linear combination of columns of 𝐴?</li><li>Is 𝑏 in the span of the columns of 𝐴?</li><li>is consistent?</li><li>is b in Col A?</li></ul><h2 id="How-many-solutions"><a href="#How-many-solutions" class="headerlink" title="How many solutions"></a>How many solutions</h2><ul><li><p>Columns of A are dependent &lt;—-&gt;If Ax=b have solution, it will have Infinite solutions</p></li><li><p>Columns of A are independent &lt;—-&gt;if Ax=b have solution ,it will have only one solution</p></li></ul><h2 id="Rank-and-Nullity"><a href="#Rank-and-Nullity" class="headerlink" title="Rank and Nullity"></a>Rank and Nullity</h2><ul><li><p>definition_1</p><ul><li>The rank of a matrix is defined as the maximum number of <font color="blue">linearly independent columns</font>&gt; in the matrix. </li><li>Nullity = <font color="red">Number of columns</font> - rank</li></ul></li><li><p>definition_2</p><ul><li>Rank=Number of Pivot Column</li></ul></li><li>definition_3<ul><li>Rank=Number of Non-zero rows</li></ul></li><li>definition_4<ul><li>Rank=Number of Basic Variables</li></ul></li><li>properties<ul><li>Rank A=n Nullity=0  &lt;—-&gt;   Columns of A are independent</li><li>Given a mxn matrix A:<ul><li>Rank A ≤ min(m, n)</li><li>Matrix A is full rank if Rank A = min(m,n)</li><li>In $R^m$, you cannot find more than m vectors that are independent</li></ul></li></ul></li></ul><h2 id="Inverse-of-a-Matrix"><a href="#Inverse-of-a-Matrix" class="headerlink" title="Inverse of a Matrix"></a>Inverse of a Matrix</h2><ul><li><p>definition:</p><p>A is called invertible if there is a matrix B such that $𝐴𝐵 = 𝐼$  and $𝐵𝐴 = I$ </p></li><li><p>elementary matrices</p><p>Every elementary row operation can be performed by matrix multiplication</p><ul><li><p>Interchange</p><script type="math/tex; mode=display">\color{blue}{\left[\begin{matrix} 0 & 1 \\ 1 & 0 \\\end{matrix}\right]}\color{black}{\left[\begin{matrix} a & b \\ c & d \\\end{matrix}\right]=\left[\begin{matrix} c & d \\ a & b \\\end{matrix}\right]}</script></li><li><p>Scaling</p><script type="math/tex; mode=display">\color{blue}{\left[\begin{matrix}  1 & 0 \\  0 & k \\\end{matrix}\right]}\color{black}{\left[\begin{matrix}  a & b \\  c & d \\\end{matrix}\right]=\left[\begin{matrix}  a & b \\  kc & kd \\\end{matrix}\right]}</script></li><li><p>Adding k times row i to row j</p><script type="math/tex; mode=display">\color{blue}{\left[\begin{matrix} 1 & 0 \\ k & 1 \\\end{matrix}\right]}\color{black}{\left[\begin{matrix} a & b \\ c & d \\\end{matrix}\right]=\left[\begin{matrix} a & b \\ ka+c & kb+d \\\end{matrix}\right]}</script></li></ul></li><li><p>Inverse of Elementary Matrix</p><p>Reverse elementary row operation</p></li></ul><script type="math/tex; mode=display">E_1=\left[\begin{matrix}  1 & 0 \\  k & 1 \\\end{matrix}\right]E_1^{-1}=\left[\begin{matrix}  1 & 0 \\  -k & 1 \\\end{matrix}\right]</script><ul><li><p>RREF &amp; Elementary Matrix</p><ul><li>Let A be an mxn matrix with reduced row echelon form R</li></ul><script type="math/tex; mode=display">𝐸_{𝑘}\cdots 𝐸_{2}𝐸_1𝐴 = R</script><ul><li>There exists an invertible m x m matrix P such that PA=R<script type="math/tex; mode=display">𝑃^{−1} = 𝐸_1^{−1}𝐸_2^{−1}\cdots 𝐸_𝑘^{−1}</script></li></ul></li><li><p>判断一个矩阵是否可逆</p><p>Let A be an n x n matrix. A is invertible if and only if</p><ul><li>The columns of $A$ span $R_n$</li><li>For every $b$  in $R_n$ , the system $Ax=b$  is consistent</li><li>The rank of $A$  is $n$ </li><li>The columns of $A$  are linear independent</li><li>The only solution to $Ax=0$  is the zero vector</li><li>The nullity of $A$  is zero</li><li>The reduced row echelon form of A is $I_n$</li><li>A is a product of elementary matrices</li><li>There exists an n x n matrix B such that $BA = I_n$</li><li>There exists an n x n matrix C such that $AC = I_n$ </li></ul></li></ul><h2 id="Subspace子空间"><a href="#Subspace子空间" class="headerlink" title="Subspace子空间"></a>Subspace子空间</h2><ul><li><p>definition</p><ul><li>The zero vector $0$  belongs to $V$ </li><li>If u and $w$  belong to $V$ , then $u+w$  belongs to $V$ (Closed under (vector) addition)</li><li>If u belongs to $V$ , and $c$  is a scalar, then $cu$  belongs to $V$ (Closed under scalar multiplication)</li></ul></li><li><p>special</p><p>zero subspace:the set $w$ consisting of only the zero vector in $R_n$ is a subspace of $R_n$ called the <strong>zero subspace</strong> . Asubspace og $R_n$ other than {0} is called a <strong>nonzero subspace</strong>.</p></li><li><p>properties</p><ul><li>The span of a vector set is a subspace</li><li>The <strong>null space</strong> of a matrix A is the solution set of Ax=0. It is denoted as Null A.</li><li>The <strong>column space</strong> of a matrix A is the span of its columns. it is denoted by Col A.</li><li><strong>Row space</strong> of a matrix A is the span of its rows. It is denoted as Row A. </li></ul></li></ul><h2 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h2><ul><li><p>definition</p><ul><li>Let $V$ be a nonzero subspace of $R_n$. A basis $B$ for $V$ is a linearly independent generation set of $V$ </li><li><p>$\{e_1,e_2,\cdots,e_n\}$ is a basis for $R_n$ </p><ul><li>$\{e_1,e_2,\cdots,e_n \}$ is independent</li><li>$\{e_1 , e_2 , \cdots, e_n \}$ generates $R$</li></ul></li><li><p>The pivot columns of a matrix form a basis for its columns space.</p></li></ul></li><li><p>properties</p><ul><li>S is contained in Span S</li><li>If a finite set S’ is contained in Span S, then Span S’ is also contained in Span S</li><li>For any vector z, Span S = Span S∪{z} if and only if z belongs to the Span S</li></ul></li><li><p>Theorem </p><ul><li><p>A basis is the <font color="blue">smallest generation set</font>.</p></li><li><p>A basis is the <font color="red">largest independent vector set</font> in the subspace.</p></li><li><p>Any two bases for a subspace <font color="green">contain the same number of vectors</font>.</p><ul><li>The number of vectors in a basis for a nonzero subspace V is called <font color="red">dimension</font> of V (<font color="red">dim</font> V).</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习数学篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotplit_note</title>
      <link href="/2019/12/21/matplotlib-note/"/>
      <url>/2019/12/21/matplotlib-note/</url>
      
        <content type="html"><![CDATA[<h1 id="Matplotlib学习笔记"><a href="#Matplotlib学习笔记" class="headerlink" title="Matplotlib学习笔记"></a>Matplotlib学习笔记</h1><h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h2><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>通过散点图探究数据之间的相关问题（正相关，负相关，不相关）</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport matplotlib.pyplot as pltN = 1000x = np.random.randn(N)y = np.random.randn(N)plt.scatter(x, y, c="r", marker="o", alpha=0.5)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/scatter.png" alt="散点图"></p><p>scatter(x, y, s, c, market)函数详解</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td>array_like</td></tr><tr><td>y</td><td>array_like</td></tr><tr><td>s</td><td>点的面积，</td></tr><tr><td>c</td><td>点的颜色</td></tr><tr><td>marker</td><td>点的形状（在官方文档搜索”markers”）</td></tr><tr><td>alpha</td><td>点的透明度（0-1，重叠的点颜色加深）</td></tr></tbody></table></div><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>通过折线图观察数据的变化趋势（主要是数据随时间的变化图）</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport matplotlib.pyplot as pltx = np.linspace(-10, 10, 10)y = x**2plt.plot(x, y, "go--", linewidth=2, markersize=3)plt.plot(x, y*2, color="green", linestyle="--", marker="o")plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8"""数据随时间的变化"""import numpy as npimport matplotlib.pyplot as pltimport matplotlib.dates as mdateimport datetimefig = plt.figure()ax = plt.gca()  # 获取当前的轴start = datetime.datetime(2019, 12, 1)  # 开始日期close = datetime.datetime(2019, 12, 21)  # 结束日期delta = datetime.timedelta(days=1)  # 时间间隔dates = mdate.drange(start, close, delta)  # 生成日期序列values = np.random.rand(len(dates))   # 模拟数据变化date_format=mdate.DateFormatter('%Y/%m/%d')ax.xaxis.set_major_formatter(date_format)  # 设置主定位器为日期格式fig.autofmt_xdate()  # 自动调整日期显示位置，避免日期之间相互重叠plt.plot_date(dates, values, "b-")  # 绘图plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/carve.png" alt="折线图"></p><p><img src="/images/matplotplit-notes/carve_time.png" alt="时间折线图"></p><p>plot([x], y, [fmt], [x2], y2, [fmt2],linewidth, markersize, label )</p><p>plot(x, y, color, marker, linestyle, linewidth, matkersize, label)</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td>array-like,<em>x</em> values are optional and default to `range(len(y))</td></tr><tr><td>y</td><td>array-like</td></tr><tr><td>fmt</td><td>定义基本的格式，如颜色，标记，线型</td></tr><tr><td>color</td><td>颜色</td></tr><tr><td>linewidth</td><td>线型宽度</td></tr><tr><td>linestyle</td><td>线型</td></tr><tr><td>markersize</td><td>标记大小</td></tr><tr><td>label</td><td>线条名称，用于图例</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>lines</td><td>A <span style="color:red">line</span> of <code>.Line2D</code> objects representing the plotted data</td></tr></tbody></table></div><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltN = 5y = [20, 10, 30, 25, 15]index = np.arange(5)plt.bar(index, y, width=0.3, bottom=0, align="edge", edgecolor= "red",tick_label=["fisrt month", "second month", "third month", "forth month", "fifth month"])plt.barh(index, y, height=0.3, edgecolor="red", tick_label=["fisrt month", "second month", "third month", "forth month", "fifth month"])plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/bar2.png" alt="纵向条形图"></p><p><img src="/images/matplotplit-notes/bar3.png" alt="横向条形图"></p><p>bar(self, x, height, width=0.8, bottom=None, <em>, align=”center”, *</em>kwargs)———纵向条形图</p><p>barh(y, width, height=0.8, left=None, <em>, align=”center”,  *</em>kwargs)———横向条形图</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td>sequence of scalars</td></tr><tr><td>height</td><td>scalar or sequence of scalars</td></tr><tr><td>width</td><td>条形的宽度</td></tr><tr><td>bottom</td><td>y坐标的基值</td></tr><tr><td>align</td><td>{“center”, “edge”},x坐标的位置</td></tr><tr><td>color</td><td>柱状图表面颜色</td></tr><tr><td>edgecolor</td><td>柱状图边缘颜色</td></tr><tr><td>linewidth</td><td>线宽</td></tr><tr><td>tick_label</td><td>x坐标轴的记号，string or array-like</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltN = 5y1 = [20, 10, 30, 25, 15]y2 = [15, 20, 10, 15, 25]index = np.arange(5)plt.bar(index, y1, width=0.3)plt.bar(index+0.3, y2, width=0.3)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/bar1.png" alt="横向双条形图"></p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltN = 5y1 = [20, 10, 30, 25, 15]y2 = [15, 20, 10, 15, 25]index = np.arange(5)plt.bar(index, y1, width=0.3)plt.bar(index, y2, width=0.3, bottom=y1)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/bar4.png" alt="层叠条形图"></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>一系列高度不同的连续纵向条形组成</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltmu = 100sigma = 20x = mu + sigma*np.random.randn(2000)  # 生成正态分布（2000个数据）n, bins, patch = plt.hist(x, bins=100, color="#DDA0DD", edgecolor="black", density=True)y = ((1 / (np.sqrt(2 * np.pi) * sigma)) *np.exp(-0.5 * (1 / sigma * (bins - mu))**2))print(y)plt.plot(bins, y, "--")plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/hist1.png" alt="hist1"></p><p>hist(self, x, bins=None, range=None, density=None, weights=None, cumulative=False, bottom=None, histtype=’bar’, align=’mid’, orientation=’vertical’, rwidth=None, log=False, color=None, label=None, stacked=False, normed=None, **kwargs)</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td>array or sequence of (n,) arrays,是一个数组或者数组序列</td></tr><tr><td>bins</td><td>整数（条形的个数），或者是序列（指定每一条的范围）</td></tr><tr><td>range</td><td>条形的上界和下界，范围之外的被舍弃</td></tr><tr><td>density</td><td>true(纵轴显示频率/组距)，false(纵轴显示频数)，即归一化处理</td></tr><tr><td>alpha</td><td>透明度</td></tr><tr><td>bottom</td><td>每一个柱子的基值</td></tr><tr><td>histtype</td><td>柱子类型，默认是bar</td></tr><tr><td>rwidth</td><td>柱子之间的距离，默认为零</td></tr><tr><td>edgecolor</td><td>柱子边界的颜色</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>n</td><td>落入每一个盒子的样本数</td></tr><tr><td>bins</td><td>每一个盒子边缘的值（一共n+1个值）</td></tr><tr><td>patched</td><td>每一个柱子</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltx1 = np.random.normal(0, 0.8, 1000)  # 均值为0，标准差为0.8的正太分布x2 = np.random.normal(-2, 1, 1000)x3 =  np.random.normal(3, 2, 1000)kwargs = dict(histtype="stepfilled", alpha=0.5, density=True, bins=40)plt.hist(x1, **kwargs)plt.hist(x2, **kwargs)plt.hist(x3, **kwargs)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/hist2.png" alt="hist2"></p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># coding=utf-8import numpy as npimport matplotlib.pyplot as pltdef printf(val):    return "{:.2f}%".format(val)if __name__ == '__main__':    labels = ["SH", "BI", "SZ", "GD"]    fracs = [20, 10, 15, 5]    patches, tests, auto_tests = plt.pie(fracs, explode=[0, 0, 0.1, 0], labels=labels, autopct=printf)    plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/matplotplit-notes/pie.png" alt="pie"></p><p>pie(self, x, explode=None, labels=None, colors=None,autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0),frame=False, rotatelabels=False)</p><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>x</td><td>array-like,The wedge sizes</td></tr><tr><td>explode</td><td>array-like，数组中每一个值是偏移中心位置的半径</td></tr><tr><td>label</td><td>每一个扇形的名称</td></tr><tr><td>colors</td><td>array-like, 指定每一个扇形的颜色</td></tr><tr><td>autopct</td><td>string, or function，标签化值</td></tr><tr><td>shadow</td><td>阴影</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>patches</td><td>A sequence of :class:<code>matplotlib.patches.Wedge</code> instances</td></tr><tr><td>texts</td><td>A list of the label :class:<code>matplotlib.text.Text</code> instances.</td></tr><tr><td>autotexts</td><td>A list of :class:<code>~matplotlib.text.Text</code> instances for the numericlabels. This will only be returned if the parameter <em>autopct</em> isnot <em>None</em>.</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python第三方库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
